// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © OneCleverGuy

//+-----------------------------------------------------+
//                 INDICATOR DESCRIPTION                |
//+-----------------------------------------------------+
//#region INDICATOR DESCRIPTION

// Ultra-Single-Session-2026: A single-session indicator following the Ultra-Sessions architecture.
// Uses local session functions for session computation and local functions for rendering.
// Features: session box with optional text, high/low lines, labels, 3-mode alerts,
// trade window gating, and configurable history.

//@version=6
indicator("Single Session", shorttitle="SingleSess", precision = 5, max_lines_count=500, max_labels_count=500, max_boxes_count = 500, overlay=true)
//----------------------Imports------------------------
import OneCleverGuy/InputLibrary/1 as iLib
// (Session library functions are embedded below for the public release.)

//#endregion INDICATOR DESCRIPTION

//+-----------------------------------------------------+
//                       INPUTS                         |
//+-----------------------------------------------------+
//#region INPUTS

//#region Tooltips***************************************

tt_tz     = "Use the local timezone so that all of your session times can make sense to you."
tt_sess      = "Sessions have all the timings pre-set. Choose one and then modify how it will appear on the chart."
tt_cust       = "Times are in your chosen timezone.\nSetting the same open and close times for the session will make it a previous day session and will not create drawing for current day."
tt_clr       = "Major Color: Session text, lines, and box outline.\nMinor Color: Inside of the box and background."
tt_hilo      = "Sets the style of the high and low lines. Disabled for Daily Sessions - Use history"
tt_box          = "Sets the style of the box. Disabled for Daily Sessions - Use history"
tt_boxTxt      = "Display the session label inside the box."
tt_ahead    = "The number of bars the line will stay in front of price, stopping at line end time."
tt_xDay      = "Enter the time that you want the line to end on the chart. Check the box to extend it another day."
tt_hist      = "Display the previous days session information as you have styled it above.\nToggling the line and box setting will only effect the previous days sessions."
tt_alrtSess = "Alert when this session's high or low is broken after the session closes."
  + " If trade windows are enabled, alerts only fire when breaks occur within those windows."
  + "\nOn Break: First touch of high/low."
  + "\nClose Out: Candle closes beyond high/low."
  + "\nClose In (Sweep): Price breaks high/low but candle closes back inside range."
tt_vln       = "Vertical lines denoting the start and finish of the selected session.\nIf you do not trade immediately after your session end, use this to filter alerts."

//#endregion Tooltips

//#region Timezone**************************************

var grpTz = "Timezone"
i_tz = input.enum(iLib.Timezones.ny, "Select Time Zone",
     group = grpTz, tooltip = tt_tz)

//#endregion Timezone

//#region Session 01 - Custom Session*******************
var grpSess01 = "SESSION 01"
i_show01             = input.bool(true, "", group = grpSess01, inline = "D6")
i_sess01             = input.string("Custom", "Session", ["London", "London Lunch", "London -> NY Open", "New York", "London/NY Cross",
                                         "Asia", "Asian Lunch", "Asia -> London Open", "Daily (Market)", "Daily (Midnight)", "Custom"],
                                         group = grpSess01, inline = "D6", display = display.none, active = i_show01)
i_custLbl01         = input.string("Asia", "Label", group = grpSess01, inline = "D6", active = i_show01)
i_custSess01       = input.session("1600-0000", "Custom Session", group = grpSess01, tooltip = tt_cust, active = i_show01, display = display.none)

i_priClr01          = input.color(color.new(#4caf50, 0), "Major Color", group = grpSess01, inline = "D1", active = i_show01)
i_subClr01            = input.color(color.new(#4caf50, 90), "Minor Color", group = grpSess01, inline = "D1", active = i_show01)
i_sessBg01           = input.bool(false, "Background", group = grpSess01, inline = "D1", tooltip = tt_clr, active = i_show01)

i_showBx01             = input.bool(true, "Session Box", group = grpSess01, inline = "D3", active = i_show01)
i_bxStyle01            = input.string("dashed (╌)", "", options=["solid (─)", "dotted (┈)", "dashed (╌)"], group = grpSess01, inline = "D3", display = display.none, active = i_show01 and i_showBx01)
i_bxSize01             = input.string("1px (thin)", "", options=["1px (thin)", "2px (normal)", "3px (heavy)", "4px (thick)"], group= grpSess01, inline = "D3", display = display.none, tooltip = tt_box, active = i_show01 and i_showBx01)
i_showBxHist01         = input.bool(true, "History", group = grpSess01, inline = "D3", tooltip = tt_hist, display = display.none, active = i_show01 and i_showBx01)

i_showBxTxt01         = input.bool(false, "Box Text", group=grpSess01, inline="D7", display = display.none, active = i_show01 and i_showBx01)
i_bxTxtClr01        = input.color(color.new(#FFFFFF, 0), " ", group=grpSess01, inline="D7", display = display.none, active = i_show01 and i_showBx01 and i_showBxTxt01)
i_bxTxtSize01         = input.enum(iLib.TextSize.tiny, "Size", options=[iLib.TextSize.auto, iLib.TextSize.tiny, iLib.TextSize.small, iLib.TextSize.normal, iLib.TextSize.large, iLib.TextSize.huge], group=grpSess01, inline="D7", display = display.none, active = i_show01 and i_showBx01 and i_showBxTxt01)
i_bxTxtHAlign01       = input.enum(iLib.BoxHAlign.left, "H Align:", options=[iLib.BoxHAlign.left, iLib.BoxHAlign.center, iLib.BoxHAlign.right], group=grpSess01, inline="D7b", display = display.none, active = i_show01 and i_showBx01 and i_showBxTxt01)
i_bxTxtVAlign01       = input.enum(iLib.BoxVAlign.top, "V Align:", options=[iLib.BoxVAlign.top, iLib.BoxVAlign.center, iLib.BoxVAlign.bottom], group=grpSess01, inline="D7b", display = display.none, tooltip = tt_boxTxt, active = i_show01 and i_showBx01 and i_showBxTxt01)

i_showHL01            = input.bool(true, "Highs/Lows", group=grpSess01, inline = "D2", active = i_show01)
i_hlStyle01           = input.string("dotted (┈)", "", options=["solid (─)", "dotted (┈)", "dashed (╌)"], group = grpSess01, inline = "D2", display = display.none, active = i_show01 and i_showHL01)
i_hlSize01            = input.string("1px (thin)", "", options=["1px (thin)", "2px (normal)", "3px (heavy)", "4px (thick)"], group= grpSess01, inline = "D2", display = display.none, active = i_show01 and i_showHL01)
i_showLnHist01        = input.bool(true, "History", group=grpSess01, inline = "D2", tooltip = tt_hist, display = display.none, active = i_show01 and i_showHL01)

i_lnStart01           = input.string("Price", "Line Starts:", ["Price", "Session Start"], group = grpSess01, inline = "D4", display = display.none, active = i_show01 and i_showHL01)
i_ahead01           = input.int(10, "Frontrun", minval = 1, maxval = 50, step = 1, group=grpSess01, inline = "D4", tooltip=tt_ahead, display = display.none, active = i_show01 and i_showHL01)

i_lnEndHr01         = input.string("17", "Line Ends", options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23"],
                             inline="D5", group=grpSess01, display = display.none, active = i_show01 and i_showHL01)
i_lnEndMin01       = input.string("00", ":", options=["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24",
                                     "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53",
                                     "54", "55", "56", "57", "58", "59"], inline="D5", group=grpSess01,  display = display.none, active = i_show01 and i_showHL01)
i_lnEndTime01         = i_lnEndHr01 + ":" + i_lnEndMin01
i_lnXDay01        = input.bool(false, "+1 Day", tt_xDay, inline="D5", group=grpSess01, display = display.none, active = i_show01 and i_showHL01)

i_showLbl01           = input.bool(true, "Line Labels", group=grpSess01, inline = "D9", tooltip = tt_hilo, active = i_show01 and i_showHL01)

i_alrtSess01        = input.string("No Alerts", "Alert Mode", options=["No Alerts", "On Break", "Close Out", "Close In (Sweep)"], group = grpSess01, inline = "D8", tooltip = tt_alrtSess, active = i_show01)

//#endregion Session 01

//#region Trade Window 01*******************************

grpTW01 = "Trade Window 01"
i_showTW01     = input.bool(true, "", group = grpTW01, inline = "V")
i_tw01         = input.session("1000-1100", "Trade Window 1", group = grpTW01, inline = "V", tooltip = tt_vln, display = display.none, active = i_showTW01)

i_showTwLn01      = input.bool(true, "V-Lines", group = grpTW01, inline = "V1", active = i_showTW01)
i_twLnClr01        = input.color(color.new(#b22833, 0), "", group = grpTW01, inline = "V1", active = i_showTW01 and i_showTwLn01)
i_twBgClr01  = input.color(color.new(#b22833, 90), "", group = grpTW01, inline = "V1", active = i_showTW01)
i_twLnStyle01         = input.string("solid (─)", "", options=["solid (─)", "dotted (┈)", "dashed (╌)"], group = grpTW01, inline = "V1", display = display.none, active = i_showTW01 and i_showTwLn01)
i_twLnSize01          = input.string("1px (thin)", "", options=["1px (thin)", "2px (normal)", "3px (heavy)", "4px (thick)"], group = grpTW01, inline = "V1", display = display.none, active = i_showTW01 and i_showTwLn01)

i_twHist01  = input.bool(false, "Show History", group = grpTW01, inline = "V2", display = display.none, active = i_showTW01 and i_showTwLn01)
i_showTwBg01   = input.bool(false, "Background", group = grpTW01, inline = "V2", display = display.none, active = i_showTW01)

//#endregion Trade Window 01

//#region History****************************************

grpHist = "History"
i_showHist           = input.bool(true, "History.", group = grpHist, inline = "H1")
i_daysLim             = input.int(5, "Days to show:", 1, 90, 1, "Sets the number of days into the history that should be displayed.", group = grpHist, display = display.none, inline = "H1")

//#endregion History

//#endregion Inputs

//+-----------------------------------------------------+
//                        UDT'S                         |
//+-----------------------------------------------------+
//#region UDT's

type barTrk
    int sBar
    int hiBar
    int loBar
    int hiTm
    int loTm
    int endBar = na

type brkTrk
    int sessStart = na
    bool hiBrk = false
    bool loBrk = false
    bool hiAlrt = false
    bool loAlrt = false

//#endregion UDT's

//+-----------------------------------------------------+
//                    LIB FUNCTIONS                     |
//+-----------------------------------------------------+
//#region LIB FUNCTIONS

//#region Internal Helpers*******************************

timeSpan(string _timeSpan) =>
    switch _timeSpan
        "Minute"        => 60000
        "Minutes"       => 60000
        "Half Hour"     => 1800000
        "Hour"          => 3600000
        "Hours"         => 3600000
        "4 Hours"       => 14400000
        "8 Hours"       => 28800000
        "12 Hours"      => 43200000
        "Day"           => 86400000
        "Week"          => 604800000

sessToHoursMins(string _session) =>
    startHour = math.round(str.tonumber(str.substring(_session, 0, 2)))
    startMins = math.round(str.tonumber(str.substring(_session, 2, 4)))
    endHour = math.round(str.tonumber(str.substring(_session, 5, 7)))
    endMins = math.round(str.tonumber(str.substring(_session, 7, 9)))
    [startHour, startMins, endHour, endMins]

sessionDuration(string _session) =>
    start = math.round(str.tonumber(str.substring(_session, 0, 4)))
    end = math.round(str.tonumber(str.substring(_session, 5, 9)))
    if start >= end
        end += 2400
    calcHours = (math.floor(end / 100) - math.floor(start / 100)) * timeSpan("Hour")
    startMins = start % 100
    endMins = end % 100
    if startMins > 0
        calcHours := calcHours - timeSpan("Hour")
        startMins := 60 - startMins
    calcMins = (startMins + endMins) * timeSpan("Minute")
    calcHours + calcMins

type SessionInfo
    string labelText = na
    string session = na
    int openHour = na
    int openMinute = na
    int closeHour = na
    int closeMinute = na

var s_london = SessionInfo.new(
    "London", "0300-1200:23456", 03, 00, 12, 00
)
var s_londonLunch = SessionInfo.new(
    "London Lunch", "0500-0800:23456", 05, 00, 08, 00
)
var s_londonToNY = SessionInfo.new(
    "London to NY", "0300-0800:23456", 03, 00, 08, 00
)
var s_ny = SessionInfo.new(
    "New York", "0800-1700:23456", 08, 00, 17, 00
)
var s_nyCross = SessionInfo.new(
    "NY Cross", "0800-1200:23456", 08, 00, 12, 00
)
var s_asia = SessionInfo.new(
    "Asia", "2000-0500:23456", 20, 00, 05, 00
)
var s_asiaLunch = SessionInfo.new(
    "Asia Lunch", "0000-0300:23456", 00, 00, 03, 00
)
var s_asiaToLondon = SessionInfo.new(
    "Asia to Lon", "2000-0300:23456", 20, 00, 03, 00
)
var s_dailyMarket = SessionInfo.new(
    "Daily", "1700-1700:23456", 17, 00, 17, 00
)
var s_dailyMidnight = SessionInfo.new(
    "Daily", "0000-0000:23456", 00, 00, 00, 00
)

getSessionInfo(string _sessName) =>
    switch _sessName
        "Asia"                  => s_asia
        "Asian Lunch"           => s_asiaLunch
        "Asia -> London Open"   => s_asiaToLondon
        "London"                => s_london
        "London Lunch"          => s_londonLunch
        "London -> NY Open"     => s_londonToNY
        "New York"              => s_ny
        "London/NY Cross"       => s_nyCross
        "Daily (Market)"        => s_dailyMarket
        "Daily (Midnight)"      => s_dailyMidnight

isSession(string _session, string _timeZone = "America/New_York") =>
    not na(time(timeframe.period, _session, _timeZone))

getWeekClose() =>
    dayClose = timestamp("America/New_York", year, month, dayofmonth, 17)
    dayClose := dayofweek(dayClose) == 7 ? dayClose + timeSpan("Day") : dayClose
    currentDay = dayofweek(dayClose)
    int addedDays = 0
    if currentDay < 6
        addedDays := (6 - currentDay) * timeSpan("Day")
    dayClose + addedDays

//#endregion Internal Helpers

//#region Custom Types***********************************

type sessionData
    float highPrice
    int highTime
    line highLine
    label highLabel
    float lowPrice
    int lowTime
    line lowLine
    label lowLabel
    box square
    string sessLabelText
    int sessStartTime
    int sessEndTime
    int aheadTime
    int highLineStartTime
    int lowLineStartTime
    int lineEndTime
    int sessStartHour
    int sessEndHour
    int sessStartBarTime
    int sessEndBarTime

type sessionInputs
    bool showAll
    string sessName
    color primeColor
    color subColor
    bool showBg
    bool showHiLo
    string lineStyle
    string lineSize
    bool showLabel
    bool showBox
    string boxStyle
    string boxSize
    string startName
    string lineEnd
    bool xDay
    int aheadTime
    bool showLineHist
    bool showBoxHist
    string customLabel = na
    string customSession = na

//#endregion Custom Types

//#region Intrabar Operations****************************

adjustHighLow(int _startTime, int _endTime, float _high, float _low, int _hiTime, int _lowTime, int _timeNow) =>
    [oneMinTimeArray, oneMinHighArray, oneMinLowArray] = request.security_lower_tf(syminfo.tickerid, "1", [time, high, low], ignore_invalid_timeframe = true)
    float returnValHi = _high, float returnValLo = _low
    int returnHighTime = _hiTime, int returnLowTime = _lowTime
    if array.size(oneMinTimeArray) > 0
        for indx = 0 to array.size(oneMinTimeArray) -1
            arrTime = array.get(oneMinTimeArray, indx)
            if  arrTime >= _startTime and arrTime < _endTime
                if array.get(oneMinHighArray, indx) > returnValHi
                    returnValHi := array.get(oneMinHighArray, indx)
                    returnHighTime := _timeNow
                if array.get(oneMinLowArray, indx) < returnValLo
                    returnValLo := array.get(oneMinLowArray, indx)
                    returnLowTime := _timeNow

    [returnValHi, returnValLo, returnHighTime, returnLowTime]

isSessIntrabar(bool _isCheckingStart, SessionInfo _session, string _timeZone, int _barStart, int _barEnd, int _spanAdjust = 0) =>
    adjMidnight = _session.closeHour == 0 and _session.closeMinute == 0 and _session.openHour == 0 and _session.openMinute == 0 ? timeSpan("Day") : 0
    startTime = timestamp(_timeZone, year, month, dayofmonth, _session.openHour, _session.openMinute) + adjMidnight + _spanAdjust
    endTime = startTime + sessionDuration(_session.session)
    barStart = timestamp(syminfo.timezone, year(_barStart), month(_barStart), dayofmonth(_barStart), hour(_barStart), minute(_barStart))
    barEnd = timestamp(syminfo.timezone, year(_barEnd), month(_barEnd), dayofmonth(_barEnd), hour(_barEnd), minute(_barEnd))
    bool returnVal = false
    if _isCheckingStart
        returnVal := startTime > barStart and startTime < barEnd ? true : false
    else if not _isCheckingStart
        returnVal := endTime > barStart and endTime < barEnd ? true : false
    returnVal

//#endregion Intrabar Operations

//#region Run Time Functions ****************************

getRunTime(int _days, int _timeNow) =>
    int currentDay = dayofweek(_timeNow)
    int weekendDays = 0
    for i = 0 to _days - 1
        currentDay -= 1
        if currentDay == 0
            weekendDays += 2
            currentDay := 6
    int totalDays = _days + weekendDays
    int returnVal = _timeNow - totalDays * timeSpan("Day")
    returnVal

isRunTime(int _daysHistory, bool _isNonArray = false, bool _isDay = false, int _timeNow) =>
    int days = _daysHistory
    if not _isNonArray
        days := days == 0 ? 1 : days
    if _isDay
        days := days + 2
    bool returnVal = false
    int daysHistory =  getRunTime(days, _timeNow)
    if _timeNow > daysHistory
        if timeframe.isintraday
            returnVal := true
        else
            returnVal := false
    returnVal

//#endregion Run Time Functions

//#region Session Time Helpers **************************

getLineEndTime(string _timeZone, int _sessEnd, int _sessEndHour, int _sessEndMins, string _iLineEndName, bool _xDay, bool _isDaily) =>
    xDay = _xDay
    lineEndHour = math.round(str.tonumber(str.substring(_iLineEndName, 0, 2)))
    lineEndMin = math.round(str.tonumber(str.substring(_iLineEndName, 3, 5)))
    lineCloseTime = timestamp(_timeZone, year, month, dayofmonth, lineEndHour, lineEndMin)
    weekClose = getWeekClose()
    nextOpen = weekClose + timeSpan("Day") * 2
    if _isDaily
        xDay :=  timestamp(_timeZone, year, month, dayofmonth, _sessEndHour, _sessEndMins) ==
                 timestamp(_timeZone, year, month, dayofmonth, lineEndHour, lineEndMin) ?  true : false
    while lineCloseTime < _sessEnd
        lineCloseTime += timeSpan("Day")
    if xDay
        lineCloseTime := lineCloseTime + timeSpan("Day")
    while lineCloseTime > weekClose and lineCloseTime < nextOpen
        lineCloseTime += timeSpan("Day")
    if lineCloseTime >= nextOpen and lineCloseTime < nextOpen + timeSpan("Minute") * 5
        lineCloseTime += timeSpan("Day")
    lineCloseTime

//#endregion Session Time Helpers

//#region Helper Functions ******************************

isStartPrice(string _iStart) =>
    _iStart == "Price" ? true : false

getCustomSessionInfo(string _sessName, string _customSession =na,  string _customLabel = na) =>
    SessionInfo returnVal = na
    if _sessName != "Custom"
        returnVal := getSessionInfo(_sessName)
    if _sessName == "Custom"
        name            = _customLabel
        session         = _customSession
        [startHour, startMin, endHour, endMin] = sessToHoursMins(session)
        returnVal := SessionInfo.new(name, session, startHour, startMin, endHour, endMin)
    returnVal

isSessFirstBar(SessionInfo _session, string _timeZone = "America/New_York", int _spanAdjust = 0) =>
    sessStart = timestamp(_timeZone, year, month, dayofmonth, _session.openHour, _session.openMinute) + _spanAdjust
    isSessionStartInBar = sessStart >= time and sessStart < time_close
    bool isFirstBar = isSessionStartInBar
    isFirstBar

createSessionDataCore(sessionInputs _input, SessionInfo _sessInfo, bool _isDaily, string _timeZone, string _lineEndTimeZone, int _spanAdjust) =>
    sessStartTime = timestamp(_timeZone, year, month, dayofmonth, _sessInfo.openHour, _sessInfo.openMinute) + _spanAdjust
    sessDuration = sessionDuration(_sessInfo.session)
    sessEndTime = sessStartTime + sessDuration - 1
    sessEndTime := sessEndTime >= getWeekClose() ? sessEndTime + (timeSpan("Day") * 2) : sessEndTime
    sessionData.new(
         high,
         sessStartTime,
         na,
         na,
         low,
         sessStartTime,
         na,
         na,
         na,
         _sessInfo.labelText,
         sessStartTime,
         sessEndTime,
         _input.aheadTime,
         sessStartTime,
         sessStartTime,
         getLineEndTime(_lineEndTimeZone, sessEndTime, _sessInfo.closeHour, _sessInfo.openMinute, _input.lineEnd, _input.xDay, _isDaily),
         _sessInfo.openHour,
         _sessInfo.closeHour,
         sessStartTime,
         na
         )

firstBarSessionCore(sessionInputs _input, sessionData[] _sessDataArray, SessionInfo _sessInfo, bool _isDaily, int _spanAdjust, string _timeZone, string _lineEndTimeZone) =>
    array.unshift(_sessDataArray, createSessionDataCore(_input, _sessInfo, _isDaily, _timeZone, _lineEndTimeZone, _spanAdjust))

newHighOrLowCore(sessionData _sessData, bool _isHigher, bool _isLower, bool _isStartPrice, bool _isAdj) =>
    currentTime = timestamp(year, month, dayofmonth, hour, minute)
    if _isHigher
        _sessData.highPrice := _isAdj ? _sessData.highPrice : high
        _sessData.highTime := _isAdj ? _sessData.highTime : currentTime
        _sessData.highLineStartTime := _isStartPrice ? _sessData.highTime : _sessData.sessStartTime
    if _isLower
        _sessData.lowPrice := _isAdj ? _sessData.lowPrice : low
        _sessData.lowTime := _isAdj ? _sessData.lowTime : currentTime
        _sessData.lowLineStartTime := _isStartPrice ? _sessData.lowTime : _sessData.sessStartTime

isNewHighLowCore(string _swing, float _prevHiLo) =>
    _swing == "swingHigh" ? high > _prevHiLo : low < _prevHiLo

setAdjustedData(sessionData _data, float _highPrice, float _lowPrice, int _highTime, int _lowTime) =>
    _data.highPrice := _highPrice
    _data.lowPrice := _lowPrice
    _data.highTime := _highTime
    _data.lowTime := _lowTime

//#endregion Helper Functions

//#region Run Session Functions**************************

runSession(map<string, sessionInputs> _inputMap, string _mapKey, sessionData[] _sessDataArray, int _timeNow, string _timeZoneUser, string _timeZoneDefault, int _daysLimit) =>
    inputInfo = map.get(_inputMap, _mapKey)
    sessInfo = getCustomSessionInfo(inputInfo.sessName, inputInfo.customSession, inputInfo.customLabel)
    timeZone = inputInfo.sessName == "Custom" ? _timeZoneUser : _timeZoneDefault
    candleSpanAdjust = dayofweek(time) != dayofweek(time_close) ? timeSpan("Day") : 0
    isDaily = sessInfo.openHour == sessInfo.closeHour and sessInfo.openMinute == sessInfo.closeMinute
    isFirstBarOfSession = isSessFirstBar(sessInfo, timeZone, candleSpanAdjust)
    startFromPrice = isStartPrice(inputInfo.startName)

    if inputInfo.showAll and isRunTime(_daysLimit, false, isDaily, _timeNow)
        if isFirstBarOfSession
            firstBarSessionCore(inputInfo, _sessDataArray, sessInfo, isDaily, candleSpanAdjust, timeZone, _timeZoneUser)
            data0 = array.get(_sessDataArray, 0)
            data0.sessStartBarTime := time
        for data in _sessDataArray
            if _timeNow > data.lineEndTime
                continue
            if _timeNow < data.sessEndTime
                bool isStartIntra = isSessIntrabar(true, sessInfo, timeZone, time, time_close, candleSpanAdjust) and barstate.isconfirmed
                bool isEndIntra = isSessIntrabar(false, sessInfo, timeZone, time, time_close, candleSpanAdjust) and barstate.isconfirmed
                if isStartIntra or isEndIntra
                    endTime = isEndIntra ? data.sessEndTime : time_close
                    startTime = isStartIntra ? data.sessStartTime : time
                    highPrice = not isStartIntra and isEndIntra and not isFirstBarOfSession ? data.highPrice : 0
                    lowPrice = not isStartIntra and isEndIntra and not isFirstBarOfSession ? data.lowPrice : 69420
                    [adjHiPrice, adjLowPrice, adjHighTime, adjLowTime] = adjustHighLow(startTime, endTime, highPrice, lowPrice, data.highTime, data.lowTime, _timeNow)
                    setAdjustedData(data, adjHiPrice, adjLowPrice, adjHighTime, adjLowTime)
                    newHighOrLowCore(data, true, true, startFromPrice, true)
                else
                    isHigher = isNewHighLowCore("swingHigh", data.highPrice)
                    isLower = isNewHighLowCore("swingLow", data.lowPrice)
                    newHighOrLowCore(data, isHigher, isLower, startFromPrice, false)
            renderSessEnd = data.sessEndTime - 1
            if renderSessEnd >= time and renderSessEnd < time_close and na(data.sessEndBarTime)
                data.sessEndBarTime := time
    [sessInfo.session, inputInfo.showBg, isDaily, inputInfo.subColor, timeZone]

//#endregion Run Session

//#endregion LIB FUNCTIONS

//+-----------------------------------------------------+
//                      VARIABLES                       |
//+-----------------------------------------------------+
//#region VARIABLES

var string TZ             = iLib.timezoneToString(i_tz)
var string DEF_TZ     = str.tostring(iLib.Timezones.ny)
int NOW                     = timestamp(year, month, dayofmonth, hour, minute)
int DAY                      = dayofmonth(NOW)
var int lastDay        = na
var bool isRun              = false

// Set number of days to look in the history
i_daysLim := i_showHist ? i_daysLim : 0

//#region Initialize Data Holders************************

// Session data array
var sessArr01 = array.new<sessionData>()

// Trade window v-line arrays
var vLnStart01 = array.new<line>()
var vLnEnd01 = array.new<line>()

// Session input UDT
var sessInput01 = sessionInputs.new(i_show01, i_sess01, i_priClr01, i_subClr01, i_sessBg01, i_showHL01, i_hlStyle01, i_hlSize01, i_showLbl01, i_showBx01,
     i_bxStyle01, i_bxSize01, i_lnStart01, i_lnEndTime01, i_lnXDay01, i_ahead01, i_showLnHist01, i_showBxHist01, i_custLbl01, i_custSess01)

// Session input map
var sessInMap = map.new<string, sessionInputs>()
if barstate.isfirst
    map.put(sessInMap, "sess01", sessInput01)

var trkMap = map.new<int, barTrk>()

// Alert tracking map - keyed by session start time
var alrtMap = map.new<int, brkTrk>()

//#endregion Data Holders

//#endregion VARIABLES

//+-----------------------------------------------------+
//                      FUNCTIONS                       |
//+-----------------------------------------------------+
//#region FUNCTIONS

//#region Debug Function ********************************

debug(string _id, bool _show, int _t = time, string _s1 = na) =>
    if _show
        if _id == "sessVLines"
            log.info("sessVLines - Status:\n{0}", _s1)

//#endregion Debug Function

//#region Text Helpers **********************************

sessEnd(sessionData _d) =>
    _d.sessEndTime - 1

//#endregion Text Helpers

//#region Session V-Line Functions **********************

sessVLines(line[] _startArr, line[] _endArr, string _sess, int _daysLim, bool _hist, color _lnClr, string _lnStyle, string _lnSize, int _now) =>
    actSess = getCustomSessionInfo("Custom", _sess, "Active Session")
    if isRunTime(_daysLim, false, false, _now) and isSessFirstBar(actSess, TZ)
        addT = time + sessionDuration(actSess.session)
        lnGap = 0
        if array.size(_startArr) == 0 or _hist
            array.unshift(_startArr, line.new(time, open, time, close + lnGap, xloc.bar_time, extend.both, _lnClr, iLib.lineStyleFromString(_lnStyle), iLib.lineSizeFromString(_lnSize)))
            array.unshift(_endArr, line.new(addT, open, addT, close + lnGap, xloc.bar_time, extend.both, _lnClr, iLib.lineStyleFromString(_lnStyle), iLib.lineSizeFromString(_lnSize)))
            if array.size(_startArr) > _daysLim + 1
                line.delete(array.pop(_startArr))
                line.delete(array.pop(_endArr))
        if not _hist and array.size(_startArr) == 1
            line.set_x1(array.get(_startArr, 0), time)
            line.set_x2(array.get(_startArr, 0), time)
            line.set_x1(array.get(_endArr, 0), addT)
            line.set_x2(array.get(_endArr, 0), addT)
    true

clearSessVLines(line[] _startArr, line[] _endArr) =>
    while array.size(_startArr) > 0
        line.delete(array.pop(_startArr))
    while array.size(_endArr) > 0
        line.delete(array.pop(_endArr))
    true

//#endregion Session V-Line Functions

//#region Shape Functions *******************************

createLines(bool _isHi, bool _showLn, color _clr, string _style, string _size) =>
    line ret = na
    if _showLn and _isHi
        ret := line.new(time, high, time_close, high, xloc.bar_time, extend.none, _clr, iLib.lineStyleFromString(_style), iLib.lineSizeFromString(_size))
    if _showLn and not _isHi
        ret := line.new(time, low, time_close, low, xloc.bar_time, extend.none, _clr, iLib.lineStyleFromString(_style), iLib.lineSizeFromString(_size))
    ret

createLabels(bool _isHi, bool _showLn, bool _showLbl, string _lbl, color _clr, bool _showBox) =>
    color blank = color.new(#000000, 100)
    label ret = na
    lblStyleHi = _showBox ? label.style_label_lower_left : label.style_label_left
    lblStyleLo = _showBox ? label.style_label_upper_left : label.style_label_left
    if _showLbl and _showLn and _isHi
        ret := label.new(time_close, high, _lbl + " High", xloc = xloc.bar_time, color = blank, textcolor = _clr, yloc = yloc.price, style = lblStyleHi)
    if _showLbl and _showLn and not _isHi
        ret := label.new(time_close, low, _lbl + " Low", xloc = xloc.bar_time, color = blank, textcolor = _clr, yloc = yloc.price, style = lblStyleLo)
    ret

createBox(bool _showBox, int _endT, color _clr, string _bxSize, string _bxStyle, color _bxClr, bool _showTxt = false, string _txt = "", color _txtClr = #FFFFFF, iLib.TextSize _txtSize = iLib.TextSize.tiny, iLib.BoxHAlign _txtHAlign = iLib.BoxHAlign.left, iLib.BoxVAlign _txtVAlign = iLib.BoxVAlign.top) =>
    box ret = na
    if _showBox
        ret := box.new(time, high, _endT, low, _clr, iLib.lineSizeFromString(_bxSize), iLib.lineStyleFromString(_bxStyle), extend.none, xloc.bar_time, _bxClr, "", size.small, text_color = _clr, text_halign = text.align_left, text_valign = text.align_top)
        if _showTxt
            txtSize = _txtSize.textSize()
            hAlign = _txtHAlign.boxHAlign()
            vAlign = _txtVAlign.boxVAlign()
            box.set_text(ret, _txt)
            box.set_text_color(ret, _txtClr)
            box.set_text_size(ret, txtSize)
            box.set_text_halign(ret, hAlign)
            box.set_text_valign(ret, vAlign)
    ret

clearShapes(sessionData _d, bool _cLn, bool _cLbl, bool _cBx) =>
    it = _d
    if _cLn
        line.delete(it.highLine)
        line.delete(it.lowLine)
    if _cLbl
        label.delete(it.highLabel)
        label.delete(it.lowLabel)
    if _cBx
        box.delete(it.square)

updLblStyle(sessionData _d, bool _isOff) =>
    b = _d
    if not na(b.highLabel)
        if _isOff
            label.set_style(b.highLabel, label.style_label_lower_left)
            label.set_style(b.lowLabel, label.style_label_upper_left)
        else
            label.set_style(b.highLabel, label.style_label_left)
            label.set_style(b.lowLabel, label.style_label_left)

advHiLoLines(sessionData _d, int _keep, bool _showLbl, bool _showBox, bool _isDaily, int _now) =>
    b = _d
    int endT = sessEnd(b)
    if not na(b.highLine) and not na(b.lowLine) and map.contains(trkMap, b.sessStartTime)
        barTrk t = map.get(trkMap, b.sessStartTime)
        // Detect new high/low start bar changes
        if b.highLineStartTime != t.hiTm
            t.hiBar := bar_index
            t.hiTm := b.highLineStartTime
        if b.lowLineStartTime != t.loTm
            t.loBar := bar_index
            t.loTm := b.lowLineStartTime
        // Record lineEndBar once when time reaches lineEndTime
        if time >= b.lineEndTime and na(t.endBar)
            t.endBar := bar_index
        // Projection vs frozen
        int x2 = (not na(t.endBar) ? t.endBar : bar_index + _keep)
        line.set_xloc(b.highLine, t.hiBar, x2, xloc.bar_index)
        line.set_xloc(b.lowLine, t.loBar, x2, xloc.bar_index)
        if _showLbl and not na(b.highLabel) and not na(b.lowLabel)
            label.set_xloc(b.highLabel, x2, xloc.bar_index)
            label.set_xloc(b.lowLabel, x2, xloc.bar_index)
    if _now <= endT and _showBox and not _isDaily
        updLblStyle(b, true)
    if _now > endT and not _isDaily
        updLblStyle(b, false)

//#endregion Shape Functions

//#region History Functions *****************************

setHist(sessionData _d, sessionInputs _in, bool _isDaily, string _custLbl = na) =>
    it = _d
    i = _in
    int endT = sessEnd(it)
    if _isDaily
        // Daily sessions have no current-session drawings, so keep one historical render path active.
        bool showDailyLines = i.showHiLo
        bool showDailyBox = i.showBox
        if showDailyLines
            it.highLine := createLines(true, true, i.primeColor, i.lineStyle, i.lineSize)
            line.set_xy1(it.highLine, it.highLineStartTime, it.highPrice)
            line.set_xy2(it.highLine, it.lineEndTime, it.highPrice)
            it.lowLine := createLines(false, true, i.primeColor, i.lineStyle, i.lineSize)
            line.set_xy1(it.lowLine, it.lowLineStartTime, it.lowPrice)
            line.set_xy2(it.lowLine, it.lineEndTime, it.lowPrice)
            if i.showLabel
                it.highLabel := createLabels(true, true, true, "", i.primeColor, i.showBox)
                label.set_x(it.highLabel, it.lineEndTime)
                label.set_y(it.highLabel, it.highPrice)
                label.set_text(it.highLabel, not na(_custLbl) ? _custLbl + " High" : "PDH")
                label.set_style(it.highLabel, label.style_label_left)
                it.lowLabel := createLabels(false, true, true, "", i.primeColor, i.showBox)
                label.set_x(it.lowLabel, it.lineEndTime)
                label.set_y(it.lowLabel, it.lowPrice)
                label.set_text(it.lowLabel, not na(_custLbl) ? _custLbl + " Low" : "PDL")
                label.set_style(it.lowLabel, label.style_label_left)
            if not i.showLabel
                label.delete(it.highLabel)
                label.delete(it.lowLabel)
                it.highLabel := na
                it.lowLabel := na
        if not showDailyLines
            clearShapes(it, true, true, false)

        if showDailyBox
            it.square := createBox(true, endT, i.primeColor, i.boxSize, i.boxStyle, i.subColor)
            leftT = na(it.sessStartBarTime) ? it.sessStartTime : it.sessStartBarTime
            rightT = na(it.sessEndBarTime) ? endT : it.sessEndBarTime
            box.set_left(it.square, leftT)
            box.set_top(it.square, it.highPrice)
            box.set_right(it.square, rightT)
            box.set_bottom(it.square, it.lowPrice)
        if not showDailyBox
            clearShapes(it, false, false, true)

    if not _isDaily
        if i.showHiLo and i.showLineHist and i.showLabel
            label.set_text(it.highLabel, "H")
            label.set_style(it.highLabel, label.style_label_left)
            label.set_text(it.lowLabel, "L")
            label.set_style(it.lowLabel, label.style_label_left)

        if i.showHiLo and not i.showLineHist
            clearShapes(it, true, true, false)

        if not i.showHiLo and i.showLineHist
            // Parent section is off, so force-clear line history as well.
            clearShapes(it, true, true, false)

        if i.showBox and not i.showBoxHist
            clearShapes(it, false, false, true)
        if not i.showBox and i.showBoxHist
            // Parent section is off, so force-clear box history as well.
            clearShapes(it, false, false, true)

//#endregion History Functions

//#region Render Functions ******************************

ensureCurrShapes(sessionData _d, sessionInputs _in, bool _isDaily) =>
    if not _isDaily
        if _in.showHiLo
            if na(_d.highLine)
                _d.highLine := createLines(true, true, _in.primeColor, _in.lineStyle, _in.lineSize)
            if na(_d.lowLine)
                _d.lowLine := createLines(false, true, _in.primeColor, _in.lineStyle, _in.lineSize)
            line.set_y1(_d.highLine, _d.highPrice)
            line.set_y2(_d.highLine, _d.highPrice)
            line.set_y1(_d.lowLine, _d.lowPrice)
            line.set_y2(_d.lowLine, _d.lowPrice)
            if _in.showLabel
                if na(_d.highLabel)
                    _d.highLabel := createLabels(true, true, true, _d.sessLabelText, _in.primeColor, _in.showBox)
                if na(_d.lowLabel)
                    _d.lowLabel := createLabels(false, true, true, _d.sessLabelText, _in.primeColor, _in.showBox)
                label.set_y(_d.highLabel, _d.highPrice)
                label.set_text(_d.highLabel, _d.sessLabelText + " High")
                label.set_y(_d.lowLabel, _d.lowPrice)
                label.set_text(_d.lowLabel, _d.sessLabelText + " Low")
            if not _in.showLabel
                label.delete(_d.highLabel)
                label.delete(_d.lowLabel)
                _d.highLabel := na
                _d.lowLabel := na
        if not _in.showHiLo
            line.delete(_d.highLine)
            line.delete(_d.lowLine)
            label.delete(_d.highLabel)
            label.delete(_d.lowLabel)
            _d.highLine := na
            _d.lowLine := na
            _d.highLabel := na
            _d.lowLabel := na
        if _in.showBox
            // Nudge the box end 1ms earlier so it doesn't visually overlap the next bar on HTF
            int boxEnd = sessEnd(_d)
            if na(_d.square)
                _d.square := createBox(true, boxEnd, _in.primeColor, _in.boxSize, _in.boxStyle, _in.subColor, i_showBxTxt01, _d.sessLabelText, i_bxTxtClr01, i_bxTxtSize01, i_bxTxtHAlign01, i_bxTxtVAlign01)
            leftT = na(_d.sessStartBarTime) ? _d.sessStartTime : _d.sessStartBarTime
            rightT = na(_d.sessEndBarTime) ? boxEnd : _d.sessEndBarTime
            box.set_left(_d.square, leftT)
            box.set_top(_d.square, _d.highPrice)
            box.set_right(_d.square, rightT)
            box.set_bottom(_d.square, _d.lowPrice)
        if not _in.showBox
            box.delete(_d.square)
            _d.square := na

renderSess(map<string, sessionInputs> _inMap, string _key, sessionData[] _arr, int _now, string _tzUser, string _tzDef, int _daysLim) =>
    inInfo = map.get(_inMap, _key)
    sInfo = getCustomSessionInfo(inInfo.sessName, inInfo.customSession, inInfo.customLabel)
    tz = inInfo.sessName == "Custom" ? _tzUser : _tzDef
    spanAdj = dayofweek(time) != dayofweek(time_close) ? iLib.timeSpan("Day") : 0
    isDaily = sInfo.openHour == sInfo.closeHour and sInfo.openMinute == sInfo.closeMinute
    isFirst = isSessFirstBar(sInfo, tz, spanAdj)

    if inInfo.showAll and isRunTime(_daysLim, false, isDaily, _now)
        if isFirst and array.size(_arr) > 0
            newD = array.get(_arr, 0)
            newD.sessStartBarTime := time
            if not map.contains(trkMap, newD.sessStartTime)
                map.put(trkMap, newD.sessStartTime, barTrk.new(bar_index, bar_index, bar_index, newD.highLineStartTime, newD.lowLineStartTime))
        if isFirst and array.size(_arr) > 1
            setHist(array.get(_arr, 1), inInfo, isDaily)
        if isFirst and array.size(_arr) > _daysLim + (isDaily ? 2 : 1)
            rm = array.pop(_arr)
            clearShapes(rm, true, true, true)
            map.remove(trkMap, rm.sessStartTime)
        // For daily sessions, history toggles OFF should still keep 1 prior session visible.
        if isDaily and array.size(_arr) > 2
            for idx = 2 to array.size(_arr) - 1
                histData = array.get(_arr, idx)
                if not inInfo.showLineHist
                    clearShapes(histData, true, true, false)
                if not inInfo.showBoxHist
                    clearShapes(histData, false, false, true)
        for data in _arr
            bool isDone = map.contains(trkMap, data.sessStartTime) ? not na(map.get(trkMap, data.sessStartTime).endBar) : false
            if isDone
                continue
            if (not inInfo.showHiLo or isDaily) and _now > data.lineEndTime
                continue
            int endT = sessEnd(data)
            if endT >= time and endT < time_close and na(data.sessEndBarTime)
                data.sessEndBarTime := time
            if _now <= endT
                ensureCurrShapes(data, inInfo, isDaily)
            if inInfo.showHiLo
                advHiLoLines(data, inInfo.aheadTime, inInfo.showLabel, inInfo.showBox, isDaily, _now)
            if time > endT and time[1] <= endT
                updLblStyle(data, false)

//#endregion Render Functions

//#region Alert Functions ********************************

handleBrk(brkTrk _trk, bool _isHi, bool _cond, bool _inWin, string _msg) =>
    bool shHi = false
    bool shLo = false
    if _isHi
        if _cond and not _trk.hiBrk
            _trk.hiBrk := true
            if _inWin
                _trk.hiAlrt := true
                alert(_msg, alert.freq_once_per_bar)
                shHi := true
    else
        if _cond and not _trk.loBrk
            _trk.loBrk := true
            if _inWin
                _trk.loAlrt := true
                alert(_msg, alert.freq_once_per_bar)
                shLo := true
    [_trk, shHi, shLo]

isInTradeWin() =>
    bool hasTW = i_showTW01
    if not hasTW
        true
    else
        bool inWin1 = (i_showTW01 ? isSession(i_tw01, TZ) : false)
        inWin1

procSessBrkAlerts(sessionData[] _arr, string _mode, string _lbl, int _now) =>
    bool shHi = false
    bool shLo = false

    if _mode != "No Alerts" and array.size(_arr) > 0
        int alertDataIndex = na
        for idx = 0 to array.size(_arr) - 1
            cand = array.get(_arr, idx)
            int candEnd = sessEnd(cand)
            if _now > candEnd and _now <= cand.lineEndTime
                alertDataIndex := idx
                break

        if not na(alertDataIndex)
            sessionData data = array.get(_arr, alertDataIndex)
            int key = data.sessStartTime

            // Initialize tracker if needed
            if not map.contains(alrtMap, key)
                map.put(alrtMap, key, brkTrk.new(key, false, false, false, false))

            brkTrk trk = map.get(alrtMap, key)
            bool inWin = isInTradeWin()

            switch _mode
                "On Break" =>
                    [trkHi, h1, l1] = handleBrk(trk, true, high > data.highPrice, inWin, "Price breaking " + _lbl + " high.")
                    trk := trkHi
                    shHi := shHi or h1
                    [trkLo, h2, l2] = handleBrk(trk, false, low < data.lowPrice, inWin, "Price breaking " + _lbl + " low.")
                    trk := trkLo
                    shLo := shLo or l2
                "Close Out" =>
                    if barstate.isconfirmed
                        [trkHi, h1, l1] = handleBrk(trk, true, close > data.highPrice, inWin, "Price closed above " + _lbl + " high.")
                        trk := trkHi
                        shHi := shHi or h1
                        [trkLo, h2, l2] = handleBrk(trk, false, close < data.lowPrice, inWin, "Price closed below " + _lbl + " low.")
                        trk := trkLo
                        shLo := shLo or l2
                "Close In (Sweep)" =>
                    if barstate.isconfirmed
                        swpHi = high > data.highPrice and close <= data.highPrice
                        swpLo = low < data.lowPrice and close >= data.lowPrice
                        [trkHi, h1, l1] = handleBrk(trk, true, swpHi, inWin, "Price swept " + _lbl + " high.")
                        trk := trkHi
                        shHi := shHi or h1
                        [trkLo, h2, l2] = handleBrk(trk, false, swpLo, inWin, "Price swept " + _lbl + " low.")
                        trk := trkLo
                        shLo := shLo or l2

            // Persist tracker updates so alerts do not refire until a new session starts
            map.put(alrtMap, key, trk)

    [shHi, shLo]

cleanupAlrtMap(sessionData[] _arr) =>
    vKeys = array.new<int>()
    for data in _arr
        array.push(vKeys, data.sessStartTime)

    rmKeys = array.new<int>()
    for [key, _trk] in alrtMap
        bool found = false
        for validKey in vKeys
            if key == validKey
                found := true
                break
        if not found
            array.push(rmKeys, key)

    for key in rmKeys
        map.remove(alrtMap, key)

//#endregion Alert Functions

//#endregion FUNCTIONS

//+-----------------------------------------------------+
//                      EXECUTION                       |
//+-----------------------------------------------------+
//#region EXECUTION

//#region Runtime Gate***********************************

if na(lastDay) or DAY != lastDay
    isRun := isRunTime(i_daysLim, true, false, NOW)
    lastDay := DAY

//#endregion Runtime Gate

//#region Session 1 Pipeline****************************

[sStr01, sShowBg01, isDaily01, sSubClr01, sTz01] = runSession(sessInMap, "sess01", sessArr01, NOW, TZ, DEF_TZ, i_daysLim)
renderSess(sessInMap, "sess01", sessArr01, NOW, TZ, DEF_TZ, i_daysLim)
bgcolor(isSession(sStr01, sTz01) and i_show01 and sShowBg01 and not(isDaily01) and isRun ? sSubClr01 : na)

//#endregion Session 1 Pipeline

//#region Session Break Alerts **************************

alrtMode01 = i_show01 ? i_alrtSess01 : "No Alerts"
[shHi01, shLo01] = procSessBrkAlerts(sessArr01, alrtMode01, i_custLbl01, NOW)

sessHi01 = (i_show01 and array.size(sessArr01) > 0) ? array.get(sessArr01, 0).highPrice : na
sessLo01 = (i_show01 and array.size(sessArr01) > 0) ? array.get(sessArr01, 0).lowPrice : na
plot(sessHi01, "Session 1 High", color = i_priClr01, display = display.status_line)
plot(sessLo01, "Session 1 Low", color = i_priClr01, display = display.status_line)

// Visual markers for high breaks (triangles above bar)
plotshape(shHi01, "Session 1 High Break", shape.triangleup, location.abovebar, i_priClr01, size = size.small, display = display.all - display.status_line)

// Visual markers for low breaks (triangles below bar)
plotshape(shLo01, "Session 1 Low Break", shape.triangledown, location.belowbar, i_priClr01, size = size.small, display = display.all - display.status_line)

// Cleanup stale alert trackers periodically
if barstate.islast
    cleanupAlrtMap(sessArr01)

//#endregion Session Break Alerts

//#region Trade Window V-Lines **************************

if barstate.isconfirmed
    if i_showTW01 and i_showTwLn01
        sessVLines(vLnStart01, vLnEnd01, i_tw01, i_daysLim, i_twHist01, i_twLnClr01, i_twLnStyle01, i_twLnSize01, NOW)
    else
        clearSessVLines(vLnStart01, vLnEnd01)

// Trade window background
bgcolor(isSession(i_tw01, TZ) and i_showTW01 and i_showTwBg01 and isRun ? i_twBgClr01 : na)

//#endregion Trade Window V-Lines

//#endregion EXECUTION
